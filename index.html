<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clangen Save Editor</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        h1 { color: #a8dadc; margin-bottom: 20px; }
        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        input[type="file"] { display: none; }
        .file-label, .cat-select, .save-btn {
            padding: 10px 16px;
            border-radius: 6px;
            border: 1px solid #457b9d;
            background: #1d3557;
            color: #eee;
            font-size: 14px;
            cursor: pointer;
        }
        .file-label:hover, .cat-select:hover, .save-btn:hover { background: #264b73; }
        .save-btn {
            background: #2a6041;
            border-color: #4a9;
        }
        .save-btn:hover {
            background: #3a7a51;
        }
        .save-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .cat-select { min-width: 200px; }
        .cat-select:disabled { opacity: 0.5; cursor: not-allowed; }
        .status { color: #a8dadc; font-size: 14px; }
        .placeholder-box {
            background: #16213e;
            border: 1px solid #457b9d;
            border-radius: 8px;
            padding: 20px;
            color: #888;
            font-style: italic;
        }
        #editorSection { display: none; }
        .form-grid {
            display: grid;
            grid-template-columns: 180px 1fr;
            gap: 8px 12px;
            align-items: center;
            background: #16213e;
            border: 1px solid #457b9d;
            border-radius: 8px;
            padding: 20px;
            max-height: 500vh;
            overflow-y: auto;
        }
        .form-grid label {
            font-size: 13px;
            color: #a8dadc;
            text-align: right;
        }
        .form-grid input[type="text"],
        .form-grid input[type="number"],
        .form-grid select {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #457b9d;
            background: #1d3557;
            color: #eee;
            font-size: 13px;
            width: 100%;
        }
        .form-grid input:focus, .form-grid select:focus {
            outline: none;
            border-color: #a8dadc;
        }
        .form-grid input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .form-grid .display-only {
            color: #888;
            font-size: 13px;
        }
        .form-grid .compound {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .form-grid .compound input[type="number"] {
            width: 60px;
        }
        .form-grid .compound select {
            flex: 1;
        }
        
        /* Section header styles */
        .section-header {
            grid-column: 1 / -1;
            font-size: 16px;
            font-weight: bold;
            color: #a8dadc;
            border-bottom: 1px solid #457b9d;
            padding: 12px 0 6px 0;
            margin-top: 10px;
        }
        .section-header:first-child {
            margin-top: 0;
        }
        .section-note {
            grid-column: 1 / -1;
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
        }
        .section-note a {
            color: #6fa8dc;
            text-decoration: none;
        }
        .section-note a:hover {
            text-decoration: underline;
        }
        
        /* Array field styles */
        .array-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .array-entry {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .array-entry select {
            flex: 1;
        }
        .array-btn {
            width: 26px;
            height: 26px;
            border-radius: 4px;
            border: 1px solid #457b9d;
            background: #1d3557;
            color: #eee;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
        }
        .array-btn:hover {
            background: #264b73;
        }
        .array-btn.remove {
            color: #e76f6f;
        }
        .array-btn.remove:hover {
            background: #4a2020;
            border-color: #e76f6f;
        }
        .array-btn.add {
            color: #6fe78a;
        }
        .array-btn.add:hover {
            background: #1a4a20;
            border-color: #6fe78a;
        }
        .array-add-row {
            display: flex;
            justify-content: flex-start;
        }
    </style>
</head>
<body>
    <h1>Clangen Save Editor</h1>
    
    <div class="controls">
        <label class="file-label">
            Load clan_cats.json
            <input type="file" id="fileInput" accept=".json">
        </label>
        <select id="catSelect" class="cat-select" disabled>
            <option value="">-- Select a cat --</option>
        </select>
        <button id="saveBtn" class="save-btn" disabled>Save File</button>
        <span class="status" id="status"></span>
    </div>
    
    <div id="placeholderBox" class="placeholder-box">
        Load a clan_cats.json file to view cat data.
    </div>
    
    <div id="editorSection">
        <div class="form-grid" id="formGrid"></div>
    </div>
    <script src="dropdown-options.js"></script>
    <script src="field-definitions.js"></script>
    <script>
        let catsData = [];
        let catLookup = {};  // id -> display string
        let currentCatIndex = null;
        let originalTraits = {};  // Track original trait values per cat ID
        
        const fileInput = document.getElementById('fileInput');
        const catSelect = document.getElementById('catSelect');
        const saveBtn = document.getElementById('saveBtn');
        const placeholderBox = document.getElementById('placeholderBox');
        const editorSection = document.getElementById('editorSection');
        const formGrid = document.getElementById('formGrid');
        const status = document.getElementById('status');
        
        // Define which fields belong to which section
        const SECTION_BASIC = [
            'ID', 'name_prefix', 'name_suffix', 'specsuffix_hidden', 
            'gender', 'gender_align', 'moons', 'dead_moons', 'backstory',
            'trait', 'facets', 'skill_dict.primary', 'skill_dict.secondary'
        ];
        
        const SECTION_APPEARANCE = [
            'pelt_name', 'pelt_color', 'pelt_length',
            'sprite_newborn', 'sprite_kitten', 'sprite_adolescent', 
            'sprite_adult', 'sprite_senior', 'sprite_para_adult',
            'eye_colour', 'eye_colour2', 'reverse',
            'white_patches', 'vitiligo', 'points', 'white_patches_tint',
            'tortie_base', 'tortie_color', 'tortie_pattern', 'tortie_marking',
            'skin', 'tint', 'scars', 'accessory', 'opacity'
        ];
        
        // Tortie fields that should only be editable when pelt_name is Tortie or Calico
        const TORTIE_FIELDS = ['tortie_base', 'tortie_color', 'tortie_pattern', 'tortie_marking'];
        
        const SECTION_RELATIONSHIPS = [
            'parent1', 'parent2', 'adoptive_parents',
            'mentor', 'former_mentor', 'patrol_with_mentor',
            'mate', 'previous_mates',
            'current_apprentice', 'former_apprentices', 'faded_offspring'
        ];
        
        // Fields to skip entirely (complex objects handled elsewhere)
        const SKIP_FIELDS = ['pronouns', 'status', 'skill_dict.hidden'];
        
        // Fields that should only render if they exist on the cat
        const CONDITIONAL_FIELDS = ['facets'];
        
        // Custom display labels for certain fields
        const DISPLAY_LABELS = {
            'specsuffix_hidden': 'Hide suffix?',
            'name_prefix': 'Prefix',
            'name_suffix': 'Suffix',
            'gender_align': 'Gender Alignment',
            'skill_dict.primary': 'Primary Skill',
            'skill_dict.secondary': 'Secondary Skill',
        };
        
        // Build lookup table for cat ID -> display name
        function buildCatLookup() {
            catLookup = {};
            for (const cat of catsData) {
                catLookup[cat.ID] = `${cat.name_prefix}${cat.name_suffix} - ID #${cat.ID}`;
            }
        }
        
        // Store original traits for all cats (for facet deletion logic)
        function storeOriginalTraits() {
            originalTraits = {};
            for (const cat of catsData) {
                originalTraits[cat.ID] = cat.trait;
            }
        }
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    catsData = JSON.parse(event.target.result);
                    buildCatLookup();
                    storeOriginalTraits();
                    populateCatSelect();
                    status.textContent = `Loaded ${catsData.length} cats`;
                    placeholderBox.textContent = 'Select a cat from the dropdown.';
                    placeholderBox.style.display = 'block';
                    editorSection.style.display = 'none';
                    saveBtn.disabled = false;
                } catch (err) {
                    status.textContent = 'Error parsing JSON';
                    placeholderBox.textContent = `Error: ${err.message}`;
                }
            };
            reader.readAsText(file);
        });
        
        function populateCatSelect() {
            catSelect.innerHTML = '<option value="">-- Select a cat --</option>';
            catsData.forEach((cat, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = `${cat.ID} - ${cat.name_prefix}${cat.name_suffix}`;
                catSelect.appendChild(opt);
            });
            catSelect.disabled = false;
        }
        
        catSelect.addEventListener('change', (e) => {
            // Save current cat before switching
            if (currentCatIndex !== null) {
                applyFormDataToCat(currentCatIndex);
            }
            
            if (e.target.value === '') {
                placeholderBox.style.display = 'block';
                editorSection.style.display = 'none';
                currentCatIndex = null;
                return;
            }
            currentCatIndex = parseInt(e.target.value);
            renderForm(catsData[currentCatIndex]);
            placeholderBox.style.display = 'none';
            editorSection.style.display = 'block';
        });
        
        function getValue(obj, key) {
            if (key.includes('.')) {
                const parts = key.split('.');
                let v = obj;
                for (const p of parts) {
                    if (v == null) return null;
                    v = v[p];
                }
                return v;
            }
            return obj[key];
        }
        
        function setValue(obj, key, value) {
            if (key.includes('.')) {
                const parts = key.split('.');
                let target = obj;
                for (let i = 0; i < parts.length - 1; i++) {
                    if (target[parts[i]] == null) {
                        target[parts[i]] = {};
                    }
                    target = target[parts[i]];
                }
                target[parts[parts.length - 1]] = value;
            } else {
                obj[key] = value;
            }
        }
        
        // Check if a field should be rendered for this cat
        function shouldRenderField(cat, key) {
            if (!CONDITIONAL_FIELDS.includes(key)) return true;
            return cat.hasOwnProperty(key);
        }
        
        // Collect form data and apply to the cat object at given index
        function applyFormDataToCat(catIndex) {
            const cat = catsData[catIndex];
            let traitChanged = false;
            let newTrait = null;
            
            for (const [key, def] of Object.entries(FIELD_DEFS)) {
                if (def.inputType === 'display') continue;
                // Skip conditional fields that weren't rendered
                if (!shouldRenderField(cat, key)) continue;
                
                let value;
                
                switch (def.inputType) {
                    case 'text': {
                        const el = formGrid.querySelector(`input[type="text"][data-key="${key}"]`);
                        if (el) {
                            value = el.value.trim();
                            if (def.nullable && value === '') {
                                value = null;
                            }
                        }
                        break;
                    }
                    
                    case 'number': {
                        const el = formGrid.querySelector(`input[type="number"][data-key="${key}"]`);
                        if (el) {
                            value = parseInt(el.value) || 0;
                        }
                        break;
                    }
                    
                    case 'checkbox': {
                        const el = formGrid.querySelector(`input[type="checkbox"][data-key="${key}"]`);
                        if (el) {
                            value = el.checked;
                        }
                        break;
                    }
                    
                    case 'dropdown': {
                        const el = formGrid.querySelector(`select[data-key="${key}"]`);
                        if (el) {
                            value = el.value;
                            if (value === '<None>') {
                                value = null;
                            }
                            // Track trait changes
                            if (key === 'trait') {
                                newTrait = value;
                                if (value !== originalTraits[cat.ID]) {
                                    traitChanged = true;
                                }
                            }
                        }
                        break;
                    }
                    
                    case 'catid': {
                        const el = formGrid.querySelector(`select[data-key="${key}"][data-catid-single="true"]`);
                        if (el) {
                            value = el.value;
                            if (value === '<None>' || value === '') {
                                value = null;
                            }
                        }
                        break;
                    }
                    
                    case 'facets': {
                        const els = formGrid.querySelectorAll(`input[type="number"][data-key="${key}"]`);
                        if (els.length === 4) {
                            const parts = [];
                            els.forEach(el => parts[parseInt(el.dataset.facetIndex)] = el.value || '0');
                            value = parts.join(',');
                        }
                        break;
                    }
                    
                    case 'skill': {
                        const nameEl = formGrid.querySelector(`select[data-key="${key}"][data-skill-part="name"]`);
                        const levelEl = formGrid.querySelector(`input[data-key="${key}"][data-skill-part="level"]`);
                        const boolEl = formGrid.querySelector(`input[data-key="${key}"][data-skill-part="bool"]`);
                        
                        if (nameEl) {
                            if (nameEl.value === '<None>') {
                                value = null;
                            } else {
                                const level = levelEl ? (levelEl.value || '0') : '0';
                                const bool = boolEl ? (boolEl.checked ? 'True' : 'False') : 'False';
                                value = `${nameEl.value},${level},${bool}`;
                            }
                        }
                        break;
                    }
                    
                    case 'dropdown-array': {
                        const container = formGrid.querySelector(`.array-field[data-key="${key}"]`);
                        if (container) {
                            const selects = container.querySelectorAll('select[data-array-item="true"]');
                            value = [];
                            selects.forEach(sel => {
                                if (sel.value && sel.value !== '') {
                                    value.push(sel.value);
                                }
                            });
                        }
                        break;
                    }
                    
                    case 'catid-array': {
                        const container = formGrid.querySelector(`.array-field[data-key="${key}"]`);
                        if (container) {
                            const selects = container.querySelectorAll('select[data-array-item="true"]');
                            value = [];
                            selects.forEach(sel => {
                                if (sel.value && sel.value !== '') {
                                    value.push(sel.value);
                                }
                            });
                        }
                        break;
                    }
                }
                
                if (value !== undefined) {
                    setValue(cat, key, value);
                }
            }
            
            // Handle skill_dict primary/secondary swap
            if (cat.skill_dict) {
                if (cat.skill_dict.primary === null && cat.skill_dict.secondary !== null) {
                    cat.skill_dict.primary = cat.skill_dict.secondary;
                    cat.skill_dict.secondary = null;
                }
            }
            
            // Handle trait change -> delete facets
            if (traitChanged) {
                delete cat.facets;
                // Update the stored original trait so subsequent saves don't keep deleting
                originalTraits[cat.ID] = newTrait;
            }
        }
        
        // Save button handler
        saveBtn.addEventListener('click', () => {
            // Apply current form data before saving
            if (currentCatIndex !== null) {
                applyFormDataToCat(currentCatIndex);
            }
            
            // Generate JSON
            const jsonStr = JSON.stringify(catsData, null, 4);
            
            // Trigger download
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'clan_cats.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            status.textContent = 'File saved!';
        });
        
        // Create a dropdown for a regular array entry (scars, accessories, etc.)
        function createArrayDropdown(key, options, selectedValue) {
            const select = document.createElement('select');
            select.dataset.key = key;
            select.dataset.arrayItem = 'true';
            
            const blankOpt = document.createElement('option');
            blankOpt.value = '';
            blankOpt.textContent = '';
            select.appendChild(blankOpt);
            
            for (const optVal of options) {
                const opt = document.createElement('option');
                opt.value = optVal;
                opt.textContent = optVal;
                if (optVal === selectedValue) opt.selected = true;
                select.appendChild(opt);
            }
            
            return select;
        }
        
        // Create a dropdown for cat ID selection (value = ID, display = name) - for arrays
        function createCatIdDropdown(key, selectedId) {
            const select = document.createElement('select');
            select.dataset.key = key;
            select.dataset.arrayItem = 'true';
            select.dataset.catId = 'true';
            
            const blankOpt = document.createElement('option');
            blankOpt.value = '';
            blankOpt.textContent = '';
            select.appendChild(blankOpt);
            
            const currentCatId = catsData[currentCatIndex]?.ID;
            for (const cat of catsData) {
                // Exclude the currently selected cat
                if (cat.ID === currentCatId) continue;
                
                const opt = document.createElement('option');
                opt.value = cat.ID;
                opt.textContent = catLookup[cat.ID];
                if (cat.ID === selectedId) opt.selected = true;
                select.appendChild(opt);
            }
            
            return select;
        }
        
        // Create a single cat ID dropdown (not for arrays) - used for parent1, parent2, mentor
        function createSingleCatIdDropdown(key, selectedId, nullable) {
            const select = document.createElement('select');
            select.dataset.key = key;
            select.dataset.catidSingle = 'true';
            
            if (nullable) {
                const noneOpt = document.createElement('option');
                noneOpt.value = '<None>';
                noneOpt.textContent = '<None>';
                select.appendChild(noneOpt);
            }
            
            const currentCatId = catsData[currentCatIndex]?.ID;
            for (const cat of catsData) {
                // Exclude the currently selected cat
                if (cat.ID === currentCatId) continue;
                
                const opt = document.createElement('option');
                opt.value = cat.ID;
                opt.textContent = catLookup[cat.ID];
                if (cat.ID === selectedId) opt.selected = true;
                select.appendChild(opt);
            }
            
            // Set to <None> if value is null and nullable
            if (selectedId == null && nullable) {
                select.value = '<None>';
            }
            
            return select;
        }
        
        // Create remove button
        function createRemoveButton(entryRow) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'array-btn remove';
            btn.textContent = 'âˆ’';
            btn.title = 'Remove this entry';
            btn.addEventListener('click', () => {
                entryRow.remove();
            });
            return btn;
        }
        
        // Create an array entry row for regular dropdowns
        function createArrayEntryRow(key, options, value) {
            const row = document.createElement('div');
            row.className = 'array-entry';
            
            const select = createArrayDropdown(key, options, value);
            row.appendChild(select);
            
            const removeBtn = createRemoveButton(row);
            row.appendChild(removeBtn);
            
            return row;
        }
        
        // Create an array entry row for cat ID dropdowns
        function createCatIdEntryRow(key, value) {
            const row = document.createElement('div');
            row.className = 'array-entry';
            
            const select = createCatIdDropdown(key, value);
            row.appendChild(select);
            
            const removeBtn = createRemoveButton(row);
            row.appendChild(removeBtn);
            
            return row;
        }
        
        // Create the add button row for regular arrays
        function createAddButtonRow(container, key, options) {
            const row = document.createElement('div');
            row.className = 'array-add-row';
            
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'array-btn add';
            btn.textContent = '+';
            btn.title = 'Add new entry';
            btn.addEventListener('click', () => {
                const newEntry = createArrayEntryRow(key, options, '');
                container.insertBefore(newEntry, row);
            });
            
            row.appendChild(btn);
            return row;
        }
        
        // Create the add button row for cat ID arrays
        function createCatIdAddButtonRow(container, key) {
            const row = document.createElement('div');
            row.className = 'array-add-row';
            
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'array-btn add';
            btn.textContent = '+';
            btn.title = 'Add new entry';
            btn.addEventListener('click', () => {
                const newEntry = createCatIdEntryRow(key, '');
                container.insertBefore(newEntry, row);
            });
            
            row.appendChild(btn);
            return row;
        }
        
        // Build the full array field container for regular dropdowns
        function createDropdownArrayField(key, options, values) {
            const container = document.createElement('div');
            container.className = 'array-field';
            container.dataset.key = key;
            container.dataset.arrayField = 'true';
            
            const arr = Array.isArray(values) ? values : [];
            for (const val of arr) {
                const row = createArrayEntryRow(key, options, val);
                container.appendChild(row);
            }
            
            const addRow = createAddButtonRow(container, key, options);
            container.appendChild(addRow);
            
            return container;
        }
        
        // Build the full array field container for cat IDs
        function createCatIdArrayField(key, values) {
            const container = document.createElement('div');
            container.className = 'array-field';
            container.dataset.key = key;
            container.dataset.arrayField = 'true';
            container.dataset.catIdArray = 'true';
            
            const arr = Array.isArray(values) ? values : [];
            for (const val of arr) {
                const row = createCatIdEntryRow(key, val);
                container.appendChild(row);
            }
            
            const addRow = createCatIdAddButtonRow(container, key);
            container.appendChild(addRow);
            
            return container;
        }
        
        // Check if pelt allows tortie editing
        function isTortiePelt(peltName) {
            return peltName === 'Tortie' || peltName === 'Calico';
        }
        
        // Update tortie fields enabled/disabled state
        function updateTortieFieldsState() {
            const peltSelect = formGrid.querySelector('select[data-key="pelt_name"]');
            const isTortie = peltSelect && isTortiePelt(peltSelect.value);
            
            for (const tortieKey of TORTIE_FIELDS) {
                const field = formGrid.querySelector(`select[data-key="${tortieKey}"]`);
                if (field) {
                    field.disabled = !isTortie;
                    field.style.opacity = isTortie ? '1' : '0.5';
                    field.title = isTortie ? '' : 'Only editable for Tortie/Calico pelts';
                }
            }
        }
        
        // Render a single field row (label + input)
        function renderField(cat, key, def) {
            const val = getValue(cat, key);
            
            const lbl = document.createElement('label');
            lbl.textContent = DISPLAY_LABELS[key] || key;
            formGrid.appendChild(lbl);
            
            let input;
            
            switch (def.inputType) {
                case 'display':
                    input = document.createElement('span');
                    input.className = 'display-only';
                    input.textContent = val ?? '';
                    break;
                    
                case 'text':
                    input = document.createElement('input');
                    input.type = 'text';
                    input.value = val ?? '';
                    if (def.nullable) input.placeholder = '(none)';
                    input.dataset.key = key;
                    break;
                    
                case 'number':
                    input = document.createElement('input');
                    input.type = 'number';
                    input.value = val ?? 0;
                    input.dataset.key = key;
                    break;
                    
                case 'checkbox':
                    input = document.createElement('input');
                    input.type = 'checkbox';
                    input.checked = !!val;
                    input.dataset.key = key;
                    break;
                    
                case 'dropdown':
                    input = document.createElement('select');
                    input.dataset.key = key;
                    if (def.nullable) {
                        const noneOpt = document.createElement('option');
                        noneOpt.value = '<None>';
                        noneOpt.textContent = '<None>';
                        input.appendChild(noneOpt);
                    }
                    if (def.options) {
                        for (const optVal of def.options) {
                            const opt = document.createElement('option');
                            opt.value = optVal;
                            opt.textContent = optVal;
                            if (optVal === val) opt.selected = true;
                            input.appendChild(opt);
                        }
                    }
                    if (val == null && def.nullable) {
                        input.value = '<None>';
                    }
                    // Add change listener for pelt_name to toggle tortie fields
                    if (key === 'pelt_name') {
                        input.addEventListener('change', updateTortieFieldsState);
                    }
                    break;
                    
                case 'catid':
                    input = createSingleCatIdDropdown(key, val, def.nullable);
                    break;
                    
                case 'facets':
                    input = document.createElement('div');
                    input.className = 'compound';
                    const parts = (val || '0,0,0,0').split(',');
                    for (let i = 0; i < 4; i++) {
                        const fi = document.createElement('input');
                        fi.type = 'number';
                        fi.value = parts[i] || 0;
                        fi.dataset.key = key;
                        fi.dataset.facetIndex = i;
                        input.appendChild(fi);
                    }
                    break;
                    
                case 'skill':
                    input = document.createElement('div');
                    input.className = 'compound';
                    let sp = ['', '0', 'False'];
                    if (val) sp = val.split(',');
                    
                    const sd = document.createElement('select');
                    sd.dataset.key = key;
                    sd.dataset.skillPart = 'name';
                    if (def.nullable) {
                        const noneOpt = document.createElement('option');
                        noneOpt.value = '<None>';
                        noneOpt.textContent = '<None>';
                        sd.appendChild(noneOpt);
                    }
                    if (def.options) {
                        for (const optVal of def.options) {
                            const opt = document.createElement('option');
                            opt.value = optVal;
                            opt.textContent = optVal;
                            if (optVal === sp[0]) opt.selected = true;
                            sd.appendChild(opt);
                        }
                    }
                    if (!val && def.nullable) sd.value = '<None>';
                    input.appendChild(sd);
                    
                    const sl = document.createElement('input');
                    sl.type = 'number';
                    sl.value = sp[1] || 0;
                    sl.dataset.key = key;
                    sl.dataset.skillPart = 'level';
                    input.appendChild(sl);
                    
                    const sb = document.createElement('input');
                    sb.type = 'checkbox';
                    sb.checked = sp[2] === 'True';
                    sb.dataset.key = key;
                    sb.dataset.skillPart = 'bool';
                    input.appendChild(sb);
                    break;
                    
                case 'dropdown-array':
                    input = createDropdownArrayField(key, def.options || [], val);
                    break;
                    
                case 'catid-array':
                    input = createCatIdArrayField(key, val);
                    break;
                    
                default:
                    input = document.createElement('span');
                    input.className = 'display-only';
                    input.textContent = '(unknown field type)';
            }
            
            formGrid.appendChild(input);
        }
        
        // Render an unknown field as read-only
        function renderUnknownField(key, value) {
            const lbl = document.createElement('label');
            lbl.textContent = key;
            formGrid.appendChild(lbl);
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = typeof value === 'object' ? JSON.stringify(value) : (value ?? '');
            input.disabled = true;
            input.style.opacity = '0.6';
            input.title = 'Read-only: field not in definitions';
            formGrid.appendChild(input);
        }
        
        // Add a section header
        function addSectionHeader(title) {
            const header = document.createElement('div');
            header.className = 'section-header';
            header.textContent = title;
            formGrid.appendChild(header);
        }
        
        // Add a section note (like the sprite guide link)
        function addSectionNote(html) {
            const note = document.createElement('div');
            note.className = 'section-note';
            note.innerHTML = html;
            formGrid.appendChild(note);
        }
        
        function renderForm(cat) {
            formGrid.innerHTML = '';
            
            // Track which keys we've rendered
            const renderedKeys = new Set();
            
            // Helper to render a list of fields
            function renderFieldList(keys) {
                for (const key of keys) {
                    if (SKIP_FIELDS.includes(key)) continue;
                    // Skip conditional fields that don't exist on this cat
                    if (!shouldRenderField(cat, key)) continue;
                    const def = FIELD_DEFS[key];
                    if (def) {
                        renderField(cat, key, def);
                        renderedKeys.add(key);
                    }
                }
            }
            
            // Section 1: Basic info (no header)
            renderFieldList(SECTION_BASIC);
            
            // Section 2: Appearance
            addSectionHeader('Appearance');
            addSectionNote('<a href="https://docs.google.com/spreadsheets/d/18T-VPGo4GJP35ECYnkzqKZThd6t8j7TwN97QspXtXY0/edit?gid=0#gid=0" target="_blank">Visual Sprite Guide</a> - resource with images for every variation');
            renderFieldList(SECTION_APPEARANCE);
            
            // Section 3: Relationships
            addSectionHeader('Relationships');
            renderFieldList(SECTION_RELATIONSHIPS);
            
            // Section 4: Misc - everything else from FIELD_DEFS
            addSectionHeader('Misc');
            for (const [key, def] of Object.entries(FIELD_DEFS)) {
                if (renderedKeys.has(key)) continue;
                if (SKIP_FIELDS.includes(key)) continue;
                // Skip conditional fields that don't exist on this cat
                if (!shouldRenderField(cat, key)) continue;
                renderField(cat, key, def);
                renderedKeys.add(key);
            }
            
            // Also render any fields from the cat object that aren't in FIELD_DEFS
            for (const key of Object.keys(cat)) {
                if (renderedKeys.has(key)) continue;
                if (SKIP_FIELDS.includes(key)) continue;
                // Skip known complex objects we handle elsewhere
                if (key === 'pronouns' || key === 'status' || key === 'skill_dict') continue;
                renderUnknownField(key, cat[key]);
            }
            
            // Set initial state for tortie fields based on current pelt
            updateTortieFieldsState();
        }
    </script>
</body>
</html>